#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Malware capture and sandboxing module for the Advanced IoT Honeypot.
Implements secure handling, analysis, and storage of captured malware.
"""

import os
import sys
import time
import json
import hashlib
import datetime
import subprocess
import shutil
import tempfile
from typing import Dict, Any, List, Optional, Tuple, Union

from .logger import get_logger
from .config import get_config
from .database import get_database

class MalwareHandler:
    """Malware capture and analysis handler for the honeypot."""

    def __init__(self):
        """Initialize the malware handler."""
        self.logger = get_logger("malware")
        self.config = get_config()
        self.db = get_database()
        
        # Malware settings
        self.malware_config = self.config.get_malware_config()
        self.enabled = self.malware_config.get("enabled", True)
        self.capture_dir = self.malware_config.get("capture_dir", "/home/ubuntu/advanced_honeypot/malware")
        self.sandbox_dir = self.malware_config.get("sandbox_dir", "/home/ubuntu/advanced_honeypot/sandbox")
        self.max_file_size = self.malware_config.get("max_file_size", 10 * 1024 * 1024)  # 10 MB
        self.file_extensions = self.malware_config.get("file_extensions", [
            ".exe", ".dll", ".so", ".bin", ".sh", ".py", ".pl", ".php", ".jar", ".js",
            ".elf", ".mips", ".arm", ".m68k", ".sh4", ".ppc", ".x86", ".x64", ".sparc"
        ])
        
        # Create directories
        os.makedirs(self.capture_dir, exist_ok=True)
        os.makedirs(self.sandbox_dir, exist_ok=True)
        
        self.logger.info(f"Malware handler initialized, capture_dir: {self.capture_dir}, sandbox_dir: {self.sandbox_dir}")
    
    def process_file(self, file_path: str, src_ip: str, protocol: str, session_id: str) -> Dict[str, Any]:
        """
        Process a captured file for potential malware.
        
        Args:
            file_path: Path to the captured file
            src_ip: Source IP address
            protocol: Protocol (e.g., "ftp", "http")
            session_id: Session identifier
            
        Returns:
            Dictionary with file analysis results
        """
        if not self.enabled:
            return {"is_malware": False, "reason": "Malware handling disabled"}
        
        try:
            # Check if file exists
            if not os.path.isfile(file_path):
                return {"is_malware": False, "reason": "File does not exist"}
            
            # Check file size
            file_size = os.path.getsize(file_path)
            if file_size > self.max_file_size:
                self.logger.warning(
                    f"File too large: {file_path} ({file_size} bytes) from {src_ip}",
                    src_ip=src_ip,
                    file=file_path,
                    file_size=file_size,
                    protocol=protocol,
                    session_id=session_id
                )
                return {"is_malware": False, "reason": "File too large"}
            
            # Get file info
            file_info = self._get_file_info(file_path)
            file_info["src_ip"] = src_ip
            file_info["protocol"] = protocol
            file_info["session_id"] = session_id
            
            # Check if file is suspicious
            is_suspicious, reason = self._is_suspicious(file_path, file_info)
            file_info["is_suspicious"] = is_suspicious
            file_info["reason"] = reason
            
            # If suspicious, copy to malware directory
            if is_suspicious:
                malware_path = self._copy_to_malware_dir(file_path, file_info)
                file_info["malware_path"] = malware_path
                
                # Log suspicious file
                self.logger.warning(
                    f"Suspicious file captured: {file_path} from {src_ip}. Reason: {reason}",
                    src_ip=src_ip,
                    file=file_path,
                    malware_path=malware_path,
                    reason=reason,
                    protocol=protocol,
                    session_id=session_id,
                    event_type="suspicious_file"
                )
                
                # Store in database
                self._store_in_database(file_info)
                
                # Analyze in sandbox
                if self.malware_config.get("sandbox_enabled", True):
                    sandbox_results = self._analyze_in_sandbox(malware_path, file_info)
                    file_info["sandbox_results"] = sandbox_results
                    
                    # Update database with sandbox results
                    self._update_sandbox_results(file_info)
            else:
                # Log normal file
                self.logger.info(
                    f"Normal file captured: {file_path} from {src_ip}",
                    src_ip=src_ip,
                    file=file_path,
                    protocol=protocol,
                    session_id=session_id
                )
            
            return file_info
        
        except Exception as e:
            self.logger.error(
                f"Error processing file {file_path}: {e}",
                error=str(e),
                file=file_path,
                protocol=protocol
            )
            return {"is_malware": False, "reason": f"Error: {str(e)}"}
    
    def _get_file_info(self, file_path: str) -> Dict[str, Any]:
        """
        Get information about a file.
        
        Args:
            file_path: Path to the file
            
        Returns:
            Dictionary with file information
        """
        # Get file stats
        file_stat = os.stat(file_path)
        file_size = file_stat.st_size
        file_mtime = datetime.datetime.fromtimestamp(file_stat.st_mtime).isoformat()
        
        # Get file name and extension
        file_name = os.path.basename(file_path)
        file_ext = os.path.splitext(file_name)[1].lower()
        
        # Calculate hashes
        md5, sha1, sha256 = self._calculate_hashes(file_path)
        
        # Detect file type
        file_type = self._detect_file_type(file_path)
        
        return {
            "filename": file_name,
            "file_path": file_path,
            "file_size": file_size,
            "file_mtime": file_mtime,
            "file_ext": file_ext,
            "file_type": file_type,
            "md5": md5,
            "sha1": sha1,
            "sha256": sha256,
        }
    
    def _calculate_hashes(self, file_path: str) -> Tuple[str, str, str]:
        """
        Calculate MD5, SHA1, and SHA256 hashes of a file.
        
        Args:
            file_path: Path to the file
            
        Returns:
            Tuple of (md5, sha1, sha256) hashes
        """
        md5_hash = hashlib.md5()
        sha1_hash = hashlib.sha1()
        sha256_hash = hashlib.sha256()
        
        with open(file_path, "rb") as f:
            # Read file in chunks to handle large files
            for chunk in iter(lambda: f.read(4096), b""):
                md5_hash.update(chunk)
                sha1_hash.update(chunk)
                sha256_hash.update(chunk)
        
        return (
            md5_hash.hexdigest(),
            sha1_hash.hexdigest(),
            sha256_hash.hexdigest()
        )
    
    def _detect_file_type(self, file_path: str) -> str:
        """
        Detect the type of a file.
        
        Args:
            file_path: Path to the file
            
        Returns:
            File type string
        """
        try:
            # Use file command to detect file type
            result = subprocess.run(
                ["file", "--brief", file_path],
                capture_output=True,
                text=True,
                check=True
            )
            
            file_type = result.stdout.strip()
            return file_type
        
        except subprocess.SubprocessError:
            # Fallback to extension-based detection
            file_ext = os.path.splitext(file_path)[1].lower()
            
            if file_ext in [".exe", ".dll"]:
                return "Windows executable"
            elif file_ext in [".sh", ".bash"]:
                return "Shell script"
            elif file_ext in [".py"]:
                return "Python script"
            elif file_ext in [".pl"]:
                return "Perl script"
            elif file_ext in [".php"]:
                return "PHP script"
            elif file_ext in [".jar"]:
                return "Java archive"
            elif file_ext in [".js"]:
                return "JavaScript"
            elif file_ext in [".elf", ".bin"]:
                return "ELF executable"
            else:
                return "Unknown"
    
    def _is_suspicious(self, file_path: str, file_info: Dict[str, Any]) -> Tuple[bool, str]:
        """
        Check if a file is suspicious.
        
        Args:
            file_path: Path to the file
            file_info: File information dictionary
            
        Returns:
            Tuple of (is_suspicious, reason)
        """
        # Check file extension
        file_ext = file_info["file_ext"].lower()
        if file_ext in self.file_extensions:
            return True, f"Suspicious file extension: {file_ext}"
        
        # Check file type
        file_type = file_info["file_type"].lower()
        suspicious_types = [
            "executable", "script", "shell", "elf", "binary", "python", "perl", "php", "java"
        ]
        
        for suspicious_type in suspicious_types:
            if suspicious_type in file_type:
                return True, f"Suspicious file type: {file_type}"
        
        # Check file content (first 4KB)
        with open(file_path, "rb") as f:
            content = f.read(4096)
            
            # Check for shell script headers
            if content.startswith(b"#!/bin/") or content.startswith(b"#!/usr/bin/"):
                return True, "File contains shell script header"
            
            # Check for ELF header
            if content.startswith(b"\x7fELF"):
                return True, "File is an ELF executable"
            
            # Check for PE header (Windows executables)
            if b"MZ" in content[:2] and b"PE\0\0" in content:
                return True, "File is a PE executable"
            
            # Check for common malware strings
            malware_strings = [
                b"wget", b"curl", b"chmod +x", b"/dev/watchdog", b"/etc/passwd",
                b"busybox", b"botnet", b"ddos", b"mirai", b"gafgyt"
            ]
            
            for malware_string in malware_strings:
                if malware_string in content:
                    return True, f"File contains suspicious string: {malware_string.decode('utf-8', errors='ignore')}"
        
        return False, "No suspicious indicators found"
    
    def _copy_to_malware_dir(self, file_path: str, file_info: Dict[str, Any]) -> str:
        """
        Copy a suspicious file to the malware directory.
        
        Args:
            file_path: Path to the file
            file_info: File information dictionary
            
        Returns:
            Path to the copied malware file
        """
        # Create a unique filename based on timestamp and hash
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        malware_filename = f"{timestamp}_{file_info['md5']}{file_info['file_ext']}"
        malware_path = os.path.join(self.capture_dir, malware_filename)
        
        # Copy file
        shutil.copy2(file_path, malware_path)
        
        return malware_path
    
    def _store_in_database(self, file_info: Dict[str, Any]) -> None:
        """
        Store file information in the database.
        
        Args:
            file_info: File information dictionary
        """
        self.db.store_file(
            src_ip=file_info["src_ip"],
            filename=file_info["filename"],
            file_path=file_info.get("malware_path", file_info["file_path"]),
            file_size=file_info["file_size"],
            file_type=file_info["file_type"],
            md5=file_info["md5"],
            sha1=file_info["sha1"],
            sha256=file_info["sha256"],
            is_malware=file_info["is_suspicious"],
            protocol=file_info["protocol"],
            session_id=file_info["session_id"]
        )
    
    def _analyze_in_sandbox(self, malware_path: str, file_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analyze a suspicious file in a sandbox environment.
        
        Args:
            malware_path: Path to the malware file
            file_info: File information dictionary
            
        Returns:
            Dictionary with sandbox analysis results
        """
        try:
            # Create a unique sandbox directory
            sandbox_id = f"{file_info['md5']}_{int(time.time())}"
            sandbox_dir = os.path.join(self.sandbox_dir, sandbox_id)
            os.makedirs(sandbox_dir, exist_ok=True)
            
            # Copy malware to sandbox
            sandbox_malware_path = os.path.join(sandbox_dir, file_info["filename"])
            shutil.copy2(malware_path, sandbox_malware_path)
            
            # Determine analysis method based on file type
            file_type = file_info["file_type"].lower()
            
            if "shell" in file_type or file_info["file_ext"] in [".sh", ".bash"]:
                # Analyze shell script
                results = self._analyze_shell_script(sandbox_malware_path, sandbox_dir)
            elif "python" in file_type or file_info["file_ext"] == ".py":
                # Analyze Python script
                results = self._analyze_python_script(sandbox_malware_path, sandbox_dir)
            elif "elf" in file_type or "executable" in file_type:
                # Analyze ELF binary
                results = self._analyze_elf_binary(sandbox_malware_path, sandbox_dir)
            else:
                # Generic analysis
                results = self._analyze_generic(sandbox_malware_path, sandbox_dir)
            
            # Add sandbox info
            results["sandbox_id"] = sandbox_id
            results["sandbox_dir"] = sandbox_dir
            
            # Log analysis results
            self.logger.info(
                f"Sandbox analysis completed for {malware_path}, verdict: {results.get('verdict', 'unknown')}",
                malware_path=malware_path,
                sandbox_id=sandbox_id,
                verdict=results.get("verdict", "unknown")
            )
            
            return results
        
        except Exception as e:
            self.logger.error(
                f"Error analyzing file in sandbox {malware_path}: {e}",
                error=str(e),
                malware_path=malware_path
            )
            return {"error": str(e), "verdict": "error"}
    
    def _analyze_shell_script(self, script_path: str, sandbox_dir: str) -> Dict[str, Any]:
        """
        Analyze a shell script in a sandbox environment.
        
        Args:
            script_path: Path to the shell script
            sandbox_dir: Sandbox directory
            
        Returns:
            Dictionary with analysis results
        """
        # Static analysis
        with open(script_path, "r", errors="ignore") as f:
            content = f.read()
        
        # Check for suspicious commands
        suspicious_commands = [
            "wget", "curl", "tftp", "dd", "busybox", "rm -rf", "mkfifo",
            ">/dev/watchdog", ">/dev/kmem", ">/dev/mem", ">/dev/port",
            "cat /etc/passwd", "cat /etc/shadow", "cat /etc/hosts",
            "echo -e", "mknod", "nc ", "netcat", "ncat", "telnet", "socat"
        ]
        
        found_commands = []
        for cmd in suspicious_commands:
            if cmd in content:
                found_commands.append(cmd)
        
        # Check for IP addresses and URLs
        import re
        ip_pattern = r"\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b"
        url_pattern = r"https?://[^\s]+"
        
        ips = re.findall(ip_pattern, content)
        urls = re.findall(url_pattern, content)
        
        # Check for port numbers
        port_pattern = r"port\s+(\d+)|:(\d+)"
        ports = []
        for match in re.finditer(port_pattern, content):
            port = match.group(1) or match.group(2)
            if port:
                ports.append(port)
        
        # Determine verdict
        verdict = "benign"
        if found_commands:
            verdict = "suspicious"
            if len(found_commands) >= 3:
                verdict = "malicious"
        
        return {
            "type": "shell_script",
            "suspicious_commands": found_commands,
            "ips": ips,
            "urls": urls,
            "ports": ports,
            "verdict": verdict,
        }
    
    def _analyze_python_script(self, script_path: str, sandbox_dir: str) -> Dict[str, Any]:
        """
        Analyze a Python script in a sandbox environment.
        
        Args:
            script_path: Path to the Python script
            sandbox_dir: Sandbox directory
            
        Returns:
            Dictionary with analysis results
        """
        # Static analysis
        with open(script_path, "r", errors="ignore") as f:
            content = f.read()
        
        # Check for suspicious imports
        suspicious_imports = [
            "socket", "subprocess", "os.system", "shutil", "requests",
            "urllib", "ftplib", "telnetlib", "paramiko", "scapy",
            "pexpect", "pydbg", "ctypes", "mmap", "struct"
        ]
        
        found_imports = []
        for imp in suspicious_imports:
            if f"import {imp}" in content or f"from {imp}" in content:
                found_imports.append(imp)
        
        # Check for IP addresses and URLs
        import re
        ip_pattern = r"\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b"
        url_pattern = r"https?://[^\s]+"
        
        ips = re.findall(ip_pattern, content)
        urls = re.findall(url_pattern, content)
        
        # Check for suspicious functions
        suspicious_functions = [
            "exec(", "eval(", "compile(", "system(", "popen(",
            "execfile(", "execve(", "spawn", "fork(", "dup2(",
            "bind(", "listen(", "accept(", "connect(", "send(",
            "recv(", "download", "upload", "execute"
        ]
        
        found_functions = []
        for func in suspicious_functions:
            if func in content:
                found_functions.append(func)
        
        # Determine verdict
        verdict = "benign"
        if found_imports or found_functions:
            verdict = "suspicious"
            if len(found_imports) >= 3 or len(found_functions) >= 3:
                verdict = "malicious"
        
        return {
            "type": "python_script",
            "suspicious_imports": found_imports,
            "suspicious_functions": found_functions,
            "ips": ips,
            "urls": urls,
            "verdict": verdict,
        }
    
    def _analyze_elf_binary(self, binary_path: str, sandbox_dir: str) -> Dict[str, Any]:
        """
        Analyze an ELF binary in a sandbox environment.
        
        Args:
            binary_path: Path to the ELF binary
            sandbox_dir: Sandbox directory
            
        Returns:
            Dictionary with analysis results
        """
        # Static analysis using strings command
        try:
            result = subprocess.run(
                ["strings", binary_path],
                capture_output=True,
                text=True,
                check=True
            )
            
            strings_output = result.stdout
            
            # Check for suspicious strings
            suspicious_strings = [
                "/etc/passwd", "/etc/shadow", "/etc/hosts", "/proc/self/maps",
                "wget", "curl", "tftp", "busybox", "botnet", "ddos", "flood",
                "mirai", "gafgyt", "qbot", "kaiten", "tsunami", "stdapi",
                "meterpreter", "metasploit", "reverse shell", "bind shell",
                "backdoor", "rootkit", "exploit", "vulnerability", "payload"
            ]
            
            found_strings = []
            for s in suspicious_strings:
                if s in strings_output:
                    found_strings.append(s)
            
            # Check for IP addresses and URLs
            import re
            ip_pattern = r"\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b"
            url_pattern = r"https?://[^\s]+"
            
            ips = re.findall(ip_pattern, strings_output)
            urls = re.findall(url_pattern, strings_output)
            
            # Check for common library dependencies using ldd
            try:
                ldd_result = subprocess.run(
                    ["ldd", binary_path],
                    capture_output=True,
                    text=True
                )
                
                libraries = []
                if ldd_result.returncode == 0:
                    for line in ldd_result.stdout.splitlines():
                        if "=>" in line:
                            lib = line.split("=>")[0].strip()
                            libraries.append(lib)
            except:
                libraries = []
            
            # Determine verdict
            verdict = "benign"
            if found_strings:
                verdict = "suspicious"
                if len(found_strings) >= 3:
                    verdict = "malicious"
            
            return {
                "type": "elf_binary",
                "suspicious_strings": found_strings,
                "libraries": libraries,
                "ips": ips,
                "urls": urls,
                "verdict": verdict,
            }
        
        except subprocess.SubprocessError as e:
            return {
                "type": "elf_binary",
                "error": str(e),
                "verdict": "error",
            }
    
    def _analyze_generic(self, file_path: str, sandbox_dir: str) -> Dict[str, Any]:
        """
        Perform generic analysis on a file.
        
        Args:
            file_path: Path to the file
            sandbox_dir: Sandbox directory
            
        Returns:
            Dictionary with analysis results
        """
        # Static analysis using strings command
        try:
            result = subprocess.run(
                ["strings", file_path],
                capture_output=True,
                text=True,
                check=True
            )
            
            strings_output = result.stdout
            
            # Check for suspicious strings
            suspicious_strings = [
                "/etc/passwd", "/etc/shadow", "/etc/hosts", "/proc/self/maps",
                "wget", "curl", "tftp", "busybox", "botnet", "ddos", "flood",
                "mirai", "gafgyt", "qbot", "kaiten", "tsunami", "stdapi",
                "meterpreter", "metasploit", "reverse shell", "bind shell",
                "backdoor", "rootkit", "exploit", "vulnerability", "payload"
            ]
            
            found_strings = []
            for s in suspicious_strings:
                if s in strings_output:
                    found_strings.append(s)
            
            # Check for IP addresses and URLs
            import re
            ip_pattern = r"\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b"
            url_pattern = r"https?://[^\s]+"
            
            ips = re.findall(ip_pattern, strings_output)
            urls = re.findall(url_pattern, strings_output)
            
            # Determine verdict
            verdict = "benign"
            if found_strings:
                verdict = "suspicious"
                if len(found_strings) >= 3:
                    verdict = "malicious"
            
            return {
                "type": "generic",
                "suspicious_strings": found_strings,
                "ips": ips,
                "urls": urls,
                "verdict": verdict,
            }
        
        except subprocess.SubprocessError as e:
            return {
                "type": "generic",
                "error": str(e),
                "verdict": "error",
            }
    
    def _update_sandbox_results(self, file_info: Dict[str, Any]) -> None:
        """
        Update database with sandbox analysis results.
        
        Args:
            file_info: File information dictionary with sandbox results
        """
        # This would update the database with sandbox results
        # For now, just log the results
        self.logger.info(
            f"Sandbox analysis results for {file_info.get('malware_path', '')}: {file_info.get('sandbox_results', {}).get('verdict', 'unknown')}",
            malware_path=file_info.get("malware_path", ""),
            verdict=file_info.get("sandbox_results", {}).get("verdict", "unknown"),
            md5=file_info.get("md5", ""),
            sha256=file_info.get("sha256", "")
        )

# Singleton instance
_instance = None

def get_malware_handler() -> MalwareHandler:
    """
    Get the malware handler instance.
    
    Returns:
        Malware handler instance
    """
    global _instance
    
    if _instance is None:
        _instance = MalwareHandler()
    
    return _instance
